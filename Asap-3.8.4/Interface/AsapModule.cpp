// AsapModule.cpp:  The main Asap module.
//
// Copyright (C) 2008 Jakob Schiotz and Center for Individual
// Nanoparticle Functionality, Department of Physics, Technical
// University of Denmark.  Email: schiotz@fysik.dtu.dk
//
// This file is part of Asap version 3.
//
// This program is free software: you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public License
// version 3 as published by the Free Software Foundation.  Permission
// to use other versions of the GNU Lesser General Public License may
// granted by Jakob Schiotz or the head of department of the
// Department of Physics, Technical University of Denmark, as
// described in section 14 of the GNU General Public License.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// and the GNU Lesser Public License along with this program.  If not,
// see <http://www.gnu.org/licenses/>.

#include <Python.h>
#define PY_ARRAY_UNIQUE_SYMBOL Asap_Array_API
#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
#include <numpy/arrayobject.h>

#include "Asap.h"
#include "ExceptionInterface.h"
#include "PotentialInterface.h"
#include "EMTParameterProviderInterface.h"
#include "NeighborLocatorInterface.h"
#include "RDFInterface.h"
#include "ToolsInterface.h"
#include "DynamicsInterface.h"
#include "OpenMPInterface.h"
#ifdef WITH_OPENKIM
#include "OpenKIMinterface.h"
#endif
#define ALLOCATE_TIMING
#include "Timing.h"
#include "TimingResults.h"
#include "stacktrace.h"
#include "Debug.h"

namespace ASAPSPACE {

// Functions declared in the autogenerated version.cpp
string GetVersion();
string GetShortVersion();

int verbose;

#ifdef _OPENMP
AsapErrorBase *AsapGlobalException;
#endif

static PyObject *PyAsap_GetVersion(PyObject *noself, PyObject *noargs)
{
  string s = GetVersion();
  return PyString_FromString(s.c_str());
}

static PyObject *PyAsap_GetShortVersion(PyObject *noself, PyObject *noargs)
{
  string s = GetShortVersion();
  return PyString_FromString(s.c_str());
}

static PyObject *PyAsap_SetVerbose(PyObject *noself, PyObject *args)
{
  if (!PyArg_ParseTuple(args, "i:set_verbose", &verbose))
    return NULL;
  Py_RETURN_NONE;
}

static PyObject *PyAsap_HeapMallinfo(PyObject *noself, PyObject *noargs)
{
  double heap = heap_mallinfo();
  return PyFloat_FromDouble(heap);
}

static PyMethodDef AsapContents[] =
  {
    {"get_version", PyAsap_GetVersion, METH_NOARGS,
     "Get the ASAP version (descriptive string)."},
    {"get_short_version", PyAsap_GetShortVersion, METH_NOARGS,
     "Get the ASAP version (a string containing just the version number)."},
    {"set_verbose", PyAsap_SetVerbose, METH_VARARGS,
     "Set the ASAP verbosity level."},
    {"EMTDefaultParameters", PyAsap_EMTDefaultParamProvNew, METH_NOARGS,
     EMTDefaultParamProv_Docstring},
    {"EMTRasmussenParameters", PyAsap_EMTRasmussenParamProvNew,
     METH_NOARGS, EMTRasmussenParamProv_Docstring},
    {"NeighborList", (PyCFunction)PyAsap_NewNeighborList_Py,
     METH_VARARGS|METH_KEYWORDS, PyAsap_NewNeighborList_Docstring},
    {"NeighborCellLocator", (PyCFunction)PyAsap_NewNeighborCellLocator_Py,
     METH_VARARGS|METH_KEYWORDS, PyAsap_NewNeighborCellLocator_Docstring},
    {"FullNeighborList", (PyCFunction)PyAsap_NewFullNeighborList,
     METH_VARARGS|METH_KEYWORDS, PyAsap_NewFullNeighborList_Docstring},
    {"RawRDF", PyAsap_RawRDF, METH_VARARGS,
     "Calculate unnormalized Radial Distribution Function."},
    {"CoordinationNumbers", PyAsap_CoordinationNumbers, METH_VARARGS,
     "Calculate the coordination number of the atoms."},
    {"RestrictedCNA", PyAsap_RestrictedCNA, METH_VARARGS,
     "Restriced CNA analysis: finds FCC, HCP and 'other'"},
    {"timing_results", PyAsap_TimingResults, METH_NOARGS,
     "Get timing results, if enabled."},
    {"support_openmp", PyAsap_support_openmp, METH_NOARGS,
     PyAsap_support_openmp_doc},
    {"get_num_procs", PyAsap_get_num_procs, METH_NOARGS,
     PyAsap_get_num_procs_doc},
    {"set_num_threads", (PyCFunction)PyAsap_set_num_threads, METH_VARARGS|METH_KEYWORDS,
     PyAsap_set_num_threads_doc},
    {"heap_mallinfo", (PyCFunction)PyAsap_HeapMallinfo, METH_NOARGS,
     "Return heap size in kB."},
#ifdef WITH_OPENKIM
    {"OpenKIMinfo", (PyCFunction)PyAsap_NewOpenKIMinfo, METH_VARARGS|METH_KEYWORDS,
     OpenKIMinfo_Docstring},
#endif // WITH_OPENKIM
#ifdef PARALLEL
    {"DistributeAtoms", PyAsap_DistributeAtoms, METH_O,
     "Distribute atoms in a parallel simulation."},
#endif
    {NULL, NULL, 0, NULL}
  };


#ifdef STACKTRACE
#ifdef PARALLEL
// Global abort function
void asap_mpi_abort(void) {
    MPI_Abort(MPI_COMM_WORLD, 3);
}

// Global function giving rank in world communicator.  Used when aborting.
void asap_mpi_world_rank(int *rank)
{
    MPI_Comm_rank(MPI_COMM_WORLD, rank);
}
#endif // PARALLEL
#endif // STACKTRACE

} // end namespace

#ifdef PARALLEL
extern "C" ASAP_PUBLIC void initasapparallel3(void)
#else
extern "C" ASAP_PUBLIC void initasapserial3(void)
#endif
{
  verbose = 0;
#ifdef _OPENMP
  AsapGlobalException = NULL;
#endif
  
  import_array();  // Initialize the NumPy package.

#ifdef PARALLEL
  PyObject *m = Py_InitModule3("asapparallel3", AsapContents,
			       "C++ extension for Asap.\n");
#else
  PyObject *m = Py_InitModule3("asapserial3", AsapContents,
			       "C++ extension for Asap.\n");
#endif
  if (m == NULL)
    return;

#ifdef TIMING
  Timing_init();
#endif
  if (PyAsap_InitExceptionInterface(m) < 0)
    return;
  if (PyAsap_InitPotentialInterface(m) < 0)
    return;
  if (PyAsap_InitEMTParameterProviderInterface(m) < 0)
    return;
  if (PyAsap_InitNeighborLocatorInterface(m) < 0)
    return;
  if (PyAsap_InitDynamicsInterface(m) < 0)
    return;
  if (PyAsap_InitToolsInterface(m) < 0)
    return;
#ifdef WITH_OPENKIM
  if (PyAsap_InitOpenKIMInterface(m) < 0)
    return;
#endif
#ifdef PARALLEL
  if (PyAsap_InitMpiInterface(m) < 0)
    return;
  if (PyAsap_InitParallelPotentialInterface(m) < 0)
    return;
#endif

#ifdef STACKTRACE
#ifdef PARALLEL
  int rank;
  asap_mpi_world_rank(&rank);
  Asap_setSignalHandlers(rank, asap_mpi_abort);
#else  //PARALLEL
  Asap_setSignalHandlers(-1, 0);
#endif //PARALLEL
#endif //STACKTRACE

}
